const READ_PKG_UP = require('read-pkg-up');
const PATH = require('path');
const FS = require('fs-extra');
const MERGE_WITH = require('lodash.mergewith');
const EOL = require('os').EOL;

const SEP = PATH.sep;
const MOCHA_OPTS_FILE_NAME = 'mocha.opts';
const TS_CONIFG_FILE_NAME = 'tsconfig.json';

function getMochaOptsMap(mochaOptsData){

	mochaOptsData = mochaOptsData === undefined ? '' : mochaOptsData;
	mochaOptsData = mochaOptsData.toString();

	let mochaOpts = mochaOptsData.split(EOL);

	if(mochaOpts.length === 0){
		mochaOpts = mochaOptsData.split(EOL === '\n' ? '\r\n' : '\n');
	};

	mochaOpts = mochaOpts
		.map((cmd)=>cmd.trim())
		.filter((cmd)=>cmd !== "");

	let mochaOptsMap = new Map();
	for(let mochaOpt of mochaOpts){
		let mochaOptComps = mochaOpt
			.split(' ')
			.filter((comp)=> comp !== ' ');
		mochaOptsMap.set(mochaOptComps.shift().trim(),mochaOptComps.join(' ').trim());
	};

	return mochaOptsMap;
};

function mergeCustomizer(objValue, srcValue, key, object, source){
	if(objValue instanceof Array && srcValue instanceof Array){
		let arr = [];
		for(let val of srcValue){
			if(objValue.indexOf(val) === -1){
				objValue.push(val);
			};
		};
		return objValue;
	};
};

//Get package.json and mochaOpts.json
(new Promise((resolve)=>setTimeout(resolve,1000)))
	.then(()=>Promise.all([READ_PKG_UP({cwd:PATH.normalize(`${__dirname}/..`), normalize:false}), FS.readFile(PATH.normalize(`${__dirname}${SEP}${MOCHA_OPTS_FILE_NAME}`))]))
	.then((results) => {

		let result = results[0];
		result.mochaOpts = getMochaOptsMap(results[1]);
		result.mochaOptsPath = PATH.normalize(`${PATH.parse(result.path).dir}${SEP}${MOCHA_OPTS_FILE_NAME}`);
		result.tsconfigPath = PATH.normalize(`${PATH.parse(result.path).dir}${SEP}${TS_CONIFG_FILE_NAME}`);

		//Add test and test-watch commands
		MERGE_WITH(result.pkg, {
			scripts: {
				test: `mocha --opts ./${MOCHA_OPTS_FILE_NAME}`,
				"test-watch": `mocha  --opts ./${MOCHA_OPTS_FILE_NAME} --watch --watch-extensions ts tsx`
			}
		},mergeCustomizer);

		//Merge current mocha.opts with new mocha.opts
		//Ensure mocha.opts path
		//Backup current package and mocha.opts
		//Does NOT overwrite current mocha.opts
		//Add excludes to tsconfig.json
		return FS.ensureFile(result.mochaOptsPath)
			.then(()=>Promise.all([FS.readFile(result.mochaOptsPath),FS.readJson(result.tsconfigPath)]))
			.then((filesData)=>{

				let [mochaOptsData, curTsconfig] = filesData;


				result.tsconfig = curTsconfig;
				MERGE_WITH(curTsconfig, { exclude: [
					"src/**/*.test.ts"
				]},mergeCustomizer);

				mochaOptsData = mochaOptsData === undefined ? '' : mochaOptsData;
				mochaOptsData = mochaOptsData.toString();

				let mochaOpts = getMochaOptsMap(mochaOptsData);

				let mochaOptsObj = {};

				for(let [cmd, args] of result.mochaOpts){

					if(!mochaOpts.has(cmd)){
						mochaOpts.set(cmd, args);
					};
				};

				let mochaOptsStr = "";				
				for(let [cmd, args] of mochaOpts){
					mochaOptsStr += (`${cmd} ${args}`.trim() + EOL);
				};

				result.mochaOptsStr =  mochaOptsStr;

				let mochaOptsParse = PATH.parse(result.mochaOptsPath);
				mochaOptsParse.base = `.${mochaOptsParse.base}.BAK`;

				let tsconfigParse = PATH.parse(result.tsconfigPath);
				tsconfigParse.base = `.${tsconfigParse.base}.BAK`;

				let packageParse = PATH.parse(result.path);
				packageParse.base = `.${packageParse.base}.BAK`;

				return Promise.all([
					FS.copy(result.mochaOptsPath, PATH.format(mochaOptsParse),{ overwrite: true }),
					FS.copy(result.tsconfigPath, PATH.format(tsconfigParse),{ overwrite: true }),
					FS.copy(result.path, PATH.format(packageParse),{ overwrite: true })
				]);

			})
			.then(()=>result);

	})
	//Write package and mocha.opts
	.then((result)=>{
		return Promise.all([
			FS.writeFile(result.mochaOptsPath, result.mochaOptsStr),
			FS.writeJson(result.tsconfigPath, result.tsconfig, {spaces:'\t'}),
			FS.writeJson(result.path, result.pkg, {spaces:'\t'})
		]).then(()=>result);
	})
	.then((result)=> console.log(`"ts-mocha-init" complete. Updated:\n\t${result.mochaOptsPath}\n\t${result.path}\n\t${result.tsconfigPath}`))
	.catch(console.error);
